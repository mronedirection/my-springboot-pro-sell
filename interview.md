# 基于微信公众号的校园商铺系统(Spring Boot)

## 面试问题准备



### 项目相关问题

**1.为什么会做这个项目？**

我认为学校是一个很大的消费市场，这个系统可以应用在校园餐饮，跑腿，二手物品交易等领域中。在这些领域中，如果靠线下交易，会耗费更多人力物力以及更长的时间，如果有这么一个线上交易平台，既能节省人力成本，也能节约时间提升消费体验。所以我开发了这么一个校园商铺系统，去提升同学们在学校的购物体验以及购物便捷性。同时也可以借助此项目去学习使用Spring Boot以及Spring Cloud框架开发项目以及提高自己的Java开发能力。



**2.介绍一下这个项目？**

本项目以**Spring Boot**和**微信特性**为核心技术栈，实现一个从下单到接单流程完整，包含买家端和卖家端前后台功能的校园商铺系统。前端是一个运行于微信公众号的WebApp，前后端完全分离，前后端之间通过RESTful风格的接口相连。

在该项目中，我主要担任后端开发团队主要成员，负责业务划分、接口设计和接口开发、联调测试以及部署运行等任务。

项目的主要功能包括商品浏览、购物车管理、订单管理等功能。具体包括：

买家端和卖家端关于商品浏览，上下架，秒杀，订单浏览，管理等功能；

微信扫码登录、网页授权、微信支付、模版消息推送；



**3.项目的主要功能是什么？**

主要功能：

该项目是一个基于微信公众号的电子商务平台，包括商品浏览、购物车管理、订单管理等功能。

具体包括：

买家端和卖家端关于商品浏览，上下架，秒杀，订单浏览，管理等功能；

微信扫码登录、网页授权、微信支付、模版消息推送；



**4.项目中的亮点有哪些？**

技术亮点和难点：

自定义异常类，实现对项目异常的统一处理；

使用枚举类对项目中一些状态值或者错误码进行统一管理；

使用Spring AOP结合分布式session实现登录权限校验；

使用Redis分布式锁解决高并发场景下的超卖问题；

使用Redis实现数据缓存层，定义热点数据缓存到Redis，降低数据库的访问压力并提高大流量场景下数据的读取速度；



使用Spring Cloud将项目从单体架构拆分为微服务架构；

通过引入RabbitMQ 这个消息队列，优化了程序的效率；

利用nginx和Ribbon实现负载均衡，提高了访问速度；

服务发现组件使用Eureka，并将多台Eureka相互注册，实现Eureka的高可用；



*日志框架Slf4j和logback的使用；*

*使用WebSocket实现客户端与服务器端消息通信；*

*对商品和订单部分代码进行重构，将项目从单体架构拆分为微服务架构；*



**如何保证Eureka的高可用？**

比如可以将两台Eureka互相注册；

以端口号区分不同的eureka；

为了保证eureka1宕机后，client仍能注册在eureka2上，需要保证client每次都同时向eureka1和eureka2注册；

假如此时 eureka1宕机，但eureka2仍然存活，

此时client还会与eureka2保持连接，不影响服务间的互相调用；



**什么是心跳机制？**

各个微服务与服务发现组件会使用**心跳机制**来通信，

微服务启动后，会周期性（默认30S）向Eureka Server发送心跳以续约自己的“租期”，

如果Eureka Server在一定时间内（默认90S）没有接收到某个微服务实例的心跳，Eureka Server将注销该实例。



**8.担任的角色？主要负责什么模块？**

在该项目中，我主要负责后端部分代码的开发，具体涉及买家端和卖家端操纵商品和订单功能的实现；

项目初期使用单体架构，项目中的一些技术亮点主要包括：

统一异常处理，枚举类的使用，Spring AOP实现登录权限校验，分布式session，分布式缓存以及分布式锁的使用；

后期使用Spring Cloud将项目改为微服务架构，



**9.遇到的难点？怎么克服的？**

在涉及到调用微信接口进行授权登录以及支付部分时，由于对微信提供的开发文档不够熟悉，以及在调试过程中还需要使用到内网穿透，因此调试了比较长时间才调通；

主要是先根据微信提供的开发文档，逐步分解调试，每调通一步之后再进行下一步，直至整个系统都调通；



**10.做过压力测试吗？怎么测试的？**

项目中使用[Apache ab](https://www.cnblogs.com/gumuzi/p/5617232.html)进行压力测试，模拟100个用户发送500个请求，测试高并发情况下项目的稳定性；

对于秒杀场景，当大量用户在同时减库存时，可能存在上一个用户减库存后，新库存还没有保存至数据库，下一个用户就会在旧库存的基础上进行购买，这样就会导致超卖现象；

为了解决这个问题，我首先在该方法上加 synchronized 关键字进行修饰，保证方法以单线程方式执行，解决超卖问题，但是这样会导致该方法执行变慢，拖慢系统速度，此外这种方法还无法做到细粒度控制，对每个商品的抢购都会加锁，因此在秒杀所有的商品时都会很慢；

因此，最终选择使用Redis分布式锁解决高并发场景下的超卖问题，

Redis分布式锁使用到的关键命令是SETNX以及GETSET；

SETNX：当key存在时，什么也不做，返回false，当key不存在时，这种情况下等同SET命令，返回true；

GETSET：返回原来key对应的value，并用新的value替换旧的value；

在项目中，Redis锁的使用具体体现为在减库存前，根据商品Id进行加锁；

则在减库存过程中，其它线程由于无法拿到锁，无法进行进行减库存操作；

减库存完成后，再释放锁；

此外，为了避免出现死锁，在加锁时，还设置了锁的过期时间；

当某个线程没有拿到锁时，会判断锁有没有过期，如果锁已过期，则可以获得新锁；

如果锁未过期，则其它线程无法拿到锁，无法修改库存；



**什么是死锁？**

如果第一个线程拿到锁，但是由于执行出错，导致未能释放锁，则其它线程由于锁未被释放则一直拿不到锁，这种现象称为死锁；



**11.做完项目最大的收获是什么？**

对Spring Boot的使用更为熟练；

对Spring Cloud的更加了解；

熟悉了Redis的使用，比如分布式锁以及分布式缓存的解决方案；

对Java语法更为熟练，包括在项目中枚举类，注解，反射，自定义异常的使用；

对Spring AOP以及IOC的原理的理解更为深入；



**12.项目中用到的注解都有哪些？**

Spring Boot : @Controller, @ResponseBody, @RestController,@Service, @Component, @Autowired, @Entity, 

处理HTTP请求：@RequestMapping, @GetMapping, @PostMapping, 

事务：@Transactional

logback: @Slf4j

lombok: @Data, @Getter, @Setter

Redis缓存：@Cacheable, @CachePut, @CacheEvict



13.自定义注解是如何实现的？



**14.统一异常处理是怎么做的？**

在项目中，如果不做统一异常处理，则在运行过程中如果抛出异常的话，**返回给前端的就是一些没有价值的信息**；

而我们希望，不管请求成功还是失败，我们最好返回给前端一个**统一的结果**；

在项目中我编写了一个使用@**ControllerAdvice标记的异常处理类**，**对抛出的指定异常进行拦截**；

并对异常信息重新封装，将错误码和错误描述封装好后返回给前端；



**为什么要使用枚举类对状态进行统一管理？**

在该项目中，订单状态包括新订单，已完结，已取消、支付状态包括等待支付，支付成功、包括商品状态和返回给前端的状态码等等；

如果不进行统一管理的话，就会显得代码逻辑不清晰，也不方便记忆和维护；

如果使用枚举类对这些状态进行统一的管理，会更方便于后期的扩展和维护；



**15.内网穿透是干什么的？**

内网穿透就是将内网外网通过隧道打通，让内网的数据可以被外网获取，项目中使用到的内网穿透工具是natapp；



### 微信接口调用相关问题

**1.微信授权是如何实现的？**

1. 根据公众号的appId和appSecret构造一个uri;
2. 在微信客户端访问此接口，就会回调程序中对应的Controller；
3. 用户同意授权，服务端就可以获得对应的用户信息，其中最主要的信息是openId；
4. openId是微信用户在该公众号下的唯一用户标识，是微信支付的必传参数；



**2.微信支付是如何实现的？**

1. 微信用户在网页内请求**生成支付订单**；
2. 商户后台收到支付请求后，生成商户订单，**调用微信提供的统一下单API**；
3. 调用统一下单API后，会**生成预支付信息**；
4. **商户后台将预支付信息填入JSAPI页面返回给用户**，用户点击发起支付；
5. 然后**微信支付系统接收到JSAPI接口请求**，会**检查**参数**合法性**和授权域权限，**返回验证结果给用户**，**并要求支付授权，用户确认支付，输入密码，提交授权给微信支付系统**；
6. 微信支付系统验证授权后，**异步通知商户支付结果**；
7. 然后**商户后台告知用户支付处理结果**；
8. 至此，完成微信支付；



**3.微信退款如何实现？**

在项目中，当订单取消时，需要验证是否已支付，如果已支付成功，则需要退款；

微信退款比较简单，**只需要访问退款接口**，微信支付将在**收到退款请求并验证成功后**，**按照退款规则将支付款按原路退到买家账号上**。



**4.如何给关注公众号的用户推送模版消息？**

在项目中，订单完结后，会向用户推送模板消息；

在微信开发文档中表明，推送模版消息可以调用微信提供的接口，发送一个POST请求，其中必传参数主要包括用户的openId和在公众号中自定义的templateId以及需要推送的消息等参数；

当用户关注公众号后，就可以收到对应的提醒消息；



### Java相关问题

**1.Java的面向对象编程：**

面向对象编程（Object-Oriented Programming，简称OOP）是一种常见的编程范式，它将程序中的数据和操作数据的方法封装在一起，形成对象。

在Java中，一切皆对象。每个对象都拥有自己的属性和行为。属性可以通过变量来表示，行为可以通过方法来表示。在Java的面向对象编程中，我们可以使用类来定义对象的属性和方法



**2.枚举类的特点：**

枚举类型是一种特殊的数据类型，**使用enum关键字来定义**，可以包含一个或多个枚举常量，**每个常量都是枚举类型的实例**。

**有限的实例集合**：枚举类型是一种有限的实例集合，每个实例都是该枚举类型的一个唯一的、已命名的常量；

**类型安全**：枚举类型**在编译时进行静态类型检查**，这意味着编译器可以检测到在使用枚举常量时的类型错误；

**唯一性和可比性**：每个枚举常量在枚举类型中都是**唯一**的，并且**可以使用`==`操作符进行比较**；

**可读性和可维护性**：枚举类型的常量**可以直观地理解其含义**。这使得代码更易读、易理解和易于维护。

**支持方法和字段**：枚举常量可以具有字段和方法，可以为每个常量定义特定的属性和行为；

**序列化支持**：枚举类型默认实现了`Serializable`接口，可以被序列化和反序列化。





### Git相关问题

**Git入门教程**

[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743862006503a1c5bf5a783434581661a3cc2084efa000)

[菜鸟教程](http://www.runoob.com/git/git-workspace-index-repo.html)

[git官方文档](https://git-scm.com/doc)



### 计算机网络相关问题

**1.什么是Cookie？**

由于HTTP是一种**无状态协议**，服务器**无法单从网络连接上面知道访问者的身份**，为了解决这个问题，就诞生了Cookie；

Cookie实际上是**一小段的文本信息**，当客户端请求服务器时，**如果服务器需要记录该用户状态**，就**使用response向客户端浏览器颁发一个Cookie**；

客户端浏览器会把**Cookie保存起来**，当浏览器再次请求该网站时，会**将该Cookie一同提交给服务器**，服务器可以**通过检查该Cookie，以此来辨认用户状态**，同时服务器还可以根据需要修改Cookie的内容。



**2.什么是Session？**

cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，**如果 Cookie 很多，就增加了客户端与服务端的数据传输量**，为了解决这个问题，诞生了Session;

同一个客户端每次和服务端交互时，**不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID**；

这个 ID 是客户端**第一次访问服务器的时候生成的， 而且每个客户端是唯一的**；

这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了；

这个 **ID 通常是 NANE 为JSESIONID 的一个 Cookie**。



**3.Cookie和Session的区别和联系？**

**cookie的缺点：**

**不安全**，可以被用户禁止，只能保存少量的数据(大约是**4k**)，cookie的数量也有限制(大约是**几百个**)；

**cookie的优点：**

对服务器压力小；

**session的缺点：**

一般是寄生在Cookie下的，当Cookie被禁止时，Session也被禁止；

当用户访问量很大时，对服务器压力大；

**两者的区别：**

**cookie**机制采用的是**在客户端保持状态**的方案，而**session**机制采用的是**在服务器端保持状态**的方案;

**cookie不是很安全**，别人可以分析存放在本地的cookie并进行cookie欺骗，**考虑到安全应当使用session**;

**session**会在一定时间内保存在服务器上。当访问增多，**会比较占用服务器的性能**，**考虑到减轻服务器性能方面，应当使用cookie**;

**cookie保存的数据量有限**，**如果保存的信息量较多应该使用session**，单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie，可以将登陆信息等重要信息存放为session。



**4.什么是分布式session?**

如果后台应用是**单体系统**，那么session一般就是**存储在单体应用的内存中**就好，这样没有任何问题。但是如果是分布式系统，Session管理便存在问题了：

比如A用户第一次访问的时候，将会话信息存储到了Atomcat中，但是由于负载均衡的原因，第二次A用户再次请求的时候，可能会被路由到了Btomcat，此时Btomcat中就找不到之前的会话信息了。

因此，在分布式系统和微服务架构的应用中，**session必须保存在一个每个实例都可以访问到的地方**，这就有了分布式session，在本项目中是使用了Spring + Redis的解决方案，将session保存在Redis中。



**5.uri和url的区别?**

URI：定义了**资源的标识**但通常**不会包含获取该资源的方式**；

URL：定义了WEB**资源的标识**以及**获取该资源的方式**；

**URI**可以理解为URL的**超集**合，URL是URI的子集，**每一个URL都必定是一个URI**；

URL就是一种特定的URI，这种URI还包含如何获取资源的信息；



**6.RESTful风格是什么意思?**

使用URL定位资源，看Url就知道要什么；

使用HTTP动词（GET、POST、PUT、DELETE）描述操作，实现对资源的CRUD操作，看http method就知道干什么；

使用HTTP Status Code传递Server的状态信息，看http status code就知道结果如何；



### MyBatis相关问题？

**什么是 MyBatis？**

mybatis是一款用于**持久层的**、**轻量级的半自动化ORM框架**，封装了所有**jdbc操作**以及**设置查询参数**和**获取结果集**的操作，支持**自定义sql**、**存储过程**和**高级映射**，用于处理java程序与数据库之间的交互。

**什么是持久层框架？**

持久指的是**系统中数据存在的时限**，内存中的数据是不持久的，如果计算机崩溃，数据就会丢失，但是磁盘上的数据是持久的。因此，用在持久层也就是这个框架是用来将内存中的数据写入到磁盘中的，再具体一点，就是写到数据库中的，框架用于持久层，就是说这个框架是和数据库进行交互的，用于数据库中数据操作的框架。

**什么是轻量级？**

轻量级框架的概念可以简单的理解为所用框架开发的程序**启动时占用的资源少**、**对业务代码的侵入性不强**、**比较容易配置、使用和部署简单**、**独立部署即可使用无需依赖另外的框架**，这种就是轻量级框架，相反的就是重量级。

**为什么MyBatis是半自动化的？**

Mybatis 在查询关联对象或关联集合对象时，需要**手动编写 sql** 来完成，所以，称之为半自动 ORM 映射工具。

**MyBatis和JPA的区别？**

JPA：

优点：不需要写SQL语句，开发效率较高；

缺点：在复杂的多条件分页查询时，代码的编写和阅读体验较差；

MyBatis:

优点：对SQL的编写非常灵活，可以自由控制，方便后期的优化调试和跟踪；

缺点：无论再简单的CURD也需要自己编写SQL语句，编写比较麻烦，不易于维护；



### Redis相关问题？

**1.Redis缓存如何提高数据访问速度？**

第一次执行方法时，会直接访问数据库并将数据保存到Redis中，并通过参数的cacheNames和key唯一标识这条数据，之后都是访问Redis读取数据，从而提高数据的读取速度



### RabbitMQ相关问题？

为什么要用RabbitMQ？

跟其它消息队列做过对比吗？



### 日志框架相关问题？

**什么是日志框架**？

能够描述系统运行状态的所有事件都可以算作日志，包括用户下线，接口超时，数据库崩溃等事件；

日志框架是指一套能够实现日志输出的工具包。

**日志框架的能力？**

定制输出目标，输出格式，在运行时选择性的输出，配置灵活，性能优异；

**常用的日志框架**？

Spring Boot里面用的就是SLF4j和Logback，因此项目中也使用SLF4j和Logback；

使用方式：

1.引入依赖；

2.安装lombok插件；

3.在需要打印日志的类上用`@Slf4j`注解;

4.即可在类中直接使用log对象；

**日志级别**？

- DEBUG 级别曰志记录**对调试程序有帮助**的信息。
- INFO 级别日志 用来记录程序运行现场，虽然此处并未发生错误，但是**对排查其他错误具有指导意义**。
- WARN 级别日志也可以用来记录程序运行现场，但是更偏向于表明此处**有出现潜在错误的可能**。
- ERROR 级别日志表明当前程序**运行发生了错误**，需要被关注。但是当前发生的错误，**没有影响系统的继续运行**。
- FATAL 级别曰志表明当前程序运行出现了**严重的错误事件**，并且将会**导致应用程序中断**。



### 分布式相关问题？

**1.什么是分布式系统？**

随着业务量增大，单机系统无法满足系统要求，要么垂直扩展升级机器硬件，要么水平扩展堆服务器；

**分布式系统就是将不同的功能部署在不同的计算机上，一组计算机一起工作，最终实现一个完整的系统；**

**它是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。**

特点：

分布式系统是**多节点**的，在本项目中，可以将买家端和卖家端部署在不同的服务器上，这样就是分布式的；

分布式系统中，**不共享内存**，各个节点之间**只能通过网络进行通信**，在本项目中前端WebApp，通过REST API访问我们后台程序，获得数据；

优点：

这么做的好处就是

实现**高可用性**，当一个服务器宕机时，还有其它服务器可以使用，整个系统不会宕机；

**低延迟**，比如可以在不同的城市部署相同的节点，从而使流量可以达到最接近它的节点；



**2.分布式和微服务的区别？**

分布式和微服的架构**很相似**，在**功能上有些细微差别**，分布式的功能是为了**分散压力**，将不同模块部署在不同的服务器上，微服务的功能是为了**分散能力**，将服务细分化，方便开发、维护和部署；

分布式属于微服务，但是**微服务不一定是分布式**，微服务的意思是将模块拆分成一个独立的服务单元**通过接口来实现数据的交互**，但是不一定是分散在多个服务器上；



**3.分布式和集群的区别？**

- 分布式：强调的是**不同功能**模块的节点；

- 集群：强调的是**相同功能**模块的节点；

- **分布式系统中的节点都可以做成集群**，比如买家端模块，我可以部署一个到多个成为一个集群，在实际应用中很多分布式系统的节点会做成集群的形式，**集群的规模往往由这个节点的业务规模来决定**；

- 集群不一定是分布式的。

  

**4.什么是CAP原则？**

CAP原则又称CAP定理，是一个经典的分布式系统理论。CAP理论告诉我们：一个分布式系统不可能同时满足**一致性**（C：Consistency）、**可用性**（A：Availability）和**分区容错性**（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。

**一致性**：在分布式系统中，**一致性是指数据在多个节点之间能否保持一致的特性**。

**可用性**：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在**有限的时间**内**返回结果**。

**分区容错性**：分布式系统在遇到任何**网络分区故障**的时候，仍然需要能够**保证对外提供满足一致性和可用性的服务**，除非是整个网络环境都发生了故障。



**5.如何解决分布式系统下的数据一致性问题？**

分布式系统下的数据一致性指的是，**数据在多个节点之间能否保持一致的特性**。

在数据库中可以使用事务保证数据的一致性，在分布式系统中，可以使用分布式锁来保证数据的一致性，比如在该项目中使用Redis分布式锁解决了高并发场景下的超卖问题。